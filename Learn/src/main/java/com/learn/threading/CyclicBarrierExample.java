package com.learn.threading;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.concurrent.CyclicBarrier;

/*This is a Runnable task which will be executed by each thread.*/
class RunnableTask implements Runnable {

	CyclicBarrier cyclicBarrier;
	final List<Integer>list;

	public RunnableTask(CyclicBarrier cyclicBarrier,List<Integer>list ) {
		this.cyclicBarrier = cyclicBarrier;
		this.list=list;
	}

	@Override
	public void run() {
		try {

			Thread.sleep(700);
			
			int randomValue=new Random().nextInt(100);
			System.out.println(Thread.currentThread().getName() +" generate - "+randomValue);
			list.add(randomValue);/* 0 to 99*/
			
			
			System.out.println(Thread.currentThread().getName() + " is waiting for "
					+ (cyclicBarrier.getParties() - cyclicBarrier.getNumberWaiting() - 1)
					+ " other threads to reach common barrier point");
			
			
			

			/*
			 * when 3 parties will call await() method (i.e. common barrier point)
			 * CyclicBarrrierEvent will be triggered and all waiting threads will be
			 * released.
			 */

			cyclicBarrier.await();

		} catch (Exception e) {
			System.out.println(e);
		}

		System.out.println("As " + cyclicBarrier.getParties() + " threads have reached common barrier point "
				+ Thread.currentThread().getName() + " has been released");

	}

}

/*
 * CyclicBarrierFinishEvent will be called when 3 parties (Initialized with
 * CyclicBarrier object) reaches to a common barrier point.
 */

class CyclicBarrierFinishEvent implements Runnable {
	
	List<Integer>list;
	
	public  CyclicBarrierFinishEvent(List<Integer> list) {
		this.list=list;
	}

	@Override
	public void run() {
		System.out.println(
				"As 3 threads have reached common barrier point " + ", CyclicBarrrierFinishEvent has been triggered");
		
		int total =list.stream().mapToInt(i -> i).sum();
		
		System.out.println("Final total of values generated by other threads= " +total);
	}

}

public class CyclicBarrierExample {

	public static void main(String[] args) {
		
		final List<Integer>list=new ArrayList<Integer>();
		/*
		 * Create CountDownLatch with 3 parties, when all 3 parties will reach common
		 * barrier point CyclicBarrrierFinishEvent will be triggered
		 */
		CyclicBarrier cyclicBarrier = new CyclicBarrier(3, new CyclicBarrierFinishEvent(list));

		RunnableTask runnableTask1 = new RunnableTask(cyclicBarrier,list);
		RunnableTask runnableTask2 = new RunnableTask(cyclicBarrier,list);
		RunnableTask runnableTask3 = new RunnableTask(cyclicBarrier,list);

		// Create and start 3 threads
		new Thread(runnableTask1, "Thread-1").start();
		new Thread(runnableTask2, "Thread-2").start();
		new Thread(runnableTask3, "Thread-3").start();
		
		
		System.out.println("Main thread completed......");

		/*
		 * We are reusing cyclic barrier using below threads
		 * 
		 * RunnableTask runnableTask4=new RunnableTask(cyclicBarrier,4000); RunnableTask
		 * runnableTask5=new RunnableTask(cyclicBarrier,5000); RunnableTask
		 * runnableTask6=new RunnableTask(cyclicBarrier,6000);
		 * 
		 * // Create and start 3 more threads new
		 * Thread(runnableTask4,"Thread-4").start(); new
		 * Thread(runnableTask5,"Thread-5").start(); new
		 * Thread(runnableTask6,"Thread-6").start();
		 */
	}

}
